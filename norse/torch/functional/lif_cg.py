from typing import Tuple
import torch
import torch.jit

try:
    import norse_op
except ModuleNotFoundError:  # pragma: no cover
    pass

from norse.torch.functional.lif import LIFParameters, LIFFeedForwardState

def lif_cg_feed_forward_step(
    input_tensor: torch.Tensor,
    state_v: torch.Tensor = None,
    state_i: torch.Tensor = None,
    p: LIFParameters = LIFParameters(),
    dt: float = 0.001,
) -> Tuple[torch.Tensor, LIFFeedForwardState]:
    r"""Computes a single euler-integration step for a lif neuron-model.
    Note that the state voltage and current is passed in as separate torch tensors
    such that it can be called by `torch.cuda.make_graphed_callables`. 
    <https://pytorch.org/docs/master/generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables>
    The forward step takes as input the input current as generated by an arbitrary torch
    module or function. More specifically it implements one integration
    step of the following ODE

    .. math::
        \begin{align*}
            \dot{v} &= 1/\tau_{\text{mem}} (v_{\text{leak}} - v + i) \\
            \dot{i} &= -1/\tau_{\text{syn}} i
        \end{align*}

    together with the jump condition

    .. math::
        z = \Theta(v - v_{\text{th}})

    and transition equations

    .. math::
        \begin{align*}
            v &= (1-z) v + z v_{\text{reset}} \\
            i &= i + i_{\text{in}}
        \end{align*}

    where :math:`i_{\text{in}}` is meant to be the result of applying an
    arbitrary pytorch module (such as a convolution) to input spikes.

    Parameters:
        input_tensor (torch.Tensor): the input spikes at the current time step
        state_v (torch.Tensor): current membrane voltage of the LIF neuron
        state_i (torch.Tensor): electrical current of LIF neuron
        p (LIFParameters): parameters of a leaky integrate and fire neuron
        dt (float): Integration timestep to use
    """
    state = LIFFeedForwardState(v=state_v, i=state_i)
    z, v, i = norse_op.lif_super_feed_forward_step(input_tensor, state, p, dt)
    return z, v, i